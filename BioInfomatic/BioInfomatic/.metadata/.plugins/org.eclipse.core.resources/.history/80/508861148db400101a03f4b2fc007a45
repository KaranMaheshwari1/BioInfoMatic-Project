// src/main/java/com/example/bioinfo/service/ParallelGenericSearchService.java
package com.bio.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.bio.model.MatchRequest;
import com.bio.model.MatchResult;
import com.bio.utils.GenomeDataGenerator;

// FIX 2: Corrected import package for GenomeDataGenerator (assuming it is in utils)

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Service
public class ParallelGenericSearchService {

    // Dependency on a sequential search service (e.g., Naive or Rabin-Karp)
    private final NaiveSearchService naiveSearchService; 
    // ... (rest of the class remains the same)

    @Value("${app.parallel.num-threads:4}") // Read from application.properties, default to 4
    private int NUM_THREADS; 
    
    // Total genome length for simulation, as requested (100 million)
    private static final int GENOME_LENGTH = 100_000_000;
    
    // We create more tasks than threads for dynamic load balancing
    private static final int TASKS_PER_THREAD = 4;

    @Autowired
    public ParallelGenericSearchService(NaiveSearchService naiveSearchService) {
        this.naiveSearchService = naiveSearchService;
    }
    
    // ... (rest of the executeParallelSearch method remains the same)
    public MatchResult executeParallelSearch(MatchRequest request) throws Exception {
         
        // 1. Generate the Massive Genomic Data at runtime
        String pattern = request.getPattern();
        String text = GenomeDataGenerator.generateGenome(GENOME_LENGTH, pattern);
        int textLength = text.length();
        int patternLength = pattern.length();
        
        // Use 4 threads (from property) * 4 tasks/thread for dynamic balancing
        final int NUM_TASKS = NUM_THREADS * TASKS_PER_THREAD; 

        // 2. Prepare Chunks with Overlap (Master's role: Data Decomposition)
        int chunkSizeBase = textLength / NUM_TASKS;
        int overlapSize = patternLength - 1; 
        
        List<Callable<Set<Integer>>> tasks = new ArrayList<>();
        
        for (int i = 0; i < NUM_TASKS; i++) {
            final int start = i * chunkSizeBase;
            int end = (i + 1) * chunkSizeBase;
            
            // Add overlap to all but the last chunk
            if (i < NUM_TASKS - 1) {
                end += overlapSize;
            }
            
            final String chunk = text.substring(start, Math.min(end, textLength));
            
            // Create the Callable task (Worker's role)
            tasks.add(() -> {
                // Simulate variable workload (Load Imbalance Test)
                // Thread.sleep((long) (Math.random() * 50)); 
                
                // Use the injected sequential algorithm
                List<Integer> chunkMatches = naiveSearchService.search(chunk, pattern); 
                
                // Aggregate and convert local indices to absolute indices
                Set<Integer> absoluteMatches = chunkMatches.stream()
                        .map(localIndex -> start + localIndex)
                        .collect(Collectors.toSet());
                
                return absoluteMatches;
            });
        }
        
        // 3. Parallel Execution and Aggregation (Master's role: Dispatch & Gather)
        long startTime = System.nanoTime();
        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
        
        // invokeAll submits all tasks and blocks until all are complete (like imap_unordered in outcome)
        List<Future<Set<Integer>>> futures = executor.invokeAll(tasks);
        
        Set<Integer> allMatches = new HashSet<>();
        for (Future<Set<Integer>> future : futures) {
            allMatches.addAll(future.get()); // Aggregation and Collection
        }

        executor.shutdown(); // Gracefully shut down the pool
        long endTime = System.nanoTime();
        
        // 4. Construct Final Result
        MatchResult result = new MatchResult();
        result.setAlgorithm(request.getAlgorithm() + " Parallel (Dynamic)");
        result.setExecutionTimeNs(endTime - startTime);
        result.setMatchIndices(new ArrayList<>(allMatches));
        result.setTextLength(textLength);
        result.setPatternLength(patternLength);
        
        return result;
    }
}