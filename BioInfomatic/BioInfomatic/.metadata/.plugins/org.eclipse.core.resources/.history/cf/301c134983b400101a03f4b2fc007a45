package com.bio.service;

//src/main/java/com/example/bioinfo/service/ParallelGenericSearchService.java


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.bio.model.MatchResult;
import com.bio.utils.GenomeDataGenerator;

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Service
public class ParallelGenericSearchService {

 // Dependency on a sequential search service (e.g., Naive or Rabin-Karp)
 private final NaiveSearchService naiveSearchService; 

 @Value("${app.parallel.num-threads:4}") // Read from application.properties, default to 4
 private int NUM_THREADS; 
 
 // Total genome length for simulation, as requested (100 million)
 private static final int GENOME_LENGTH = 100_000_000;
 
 // We create more tasks than threads for dynamic load balancing
 private static final int TASKS_PER_THREAD = 4;

 @Autowired
 public ParallelGenericSearchService(NaiveSearchService naiveSearchService) {
     this.naiveSearchService = naiveSearchService;
 }

 /**
  * Runs any sequential search algorithm in parallel with dynamic load balancing.
  * @param request The search parameters (pattern, algorithm).
  * @param sequentialSearchMethod The actual sequential search method (e.g., Naive, KMP)
  * @return A MatchResult containing aggregated results and execution time.
  */
 public MatchResult executeParallelSearch(MatchRequest request) throws Exception {
     
     // 1. Generate the Massive Genomic Data at runtime
     String pattern = request.getPattern();
     String text = GenomeDataGenerator.generateGenome(GENOME_LENGTH, pattern);
     int textLength = text.length();
     int patternLength = pattern.length();
     
     // Use 4 threads (from property) * 4 tasks/thread for dynamic balancing
     final int NUM_TASKS = NUM_THREADS * TASKS_PER_THREAD; 

     // 2. Prepare Chunks with Overlap (Master's role: Data Decomposition)
     int chunkSizeBase = textLength / NUM_TASKS;
     int overlapSize = patternLength - 1; 
     
     List<Callable<Set<Integer>>> tasks = new ArrayList<>();
     
     for (int i = 0; i < NUM_TASKS; i++) {
         final int start = i * chunkSizeBase;
         int end = (i + 1) * chunkSizeBase;
         
         // Add overlap to all but the last chunk
         if (i < NUM_TASKS - 1) {
             end += overlapSize;
         }
         
         final String chunk = text.substring(start, Math.min(end, textLength));
         
         // Create the Callable task (Worker's role)
         tasks.add(() -> {
             // Simulate variable workload (Load Imbalance Test)
             // Thread.sleep((long) (Math.random() * 50)); 
             
             // Use the injected sequential algorithm
             List<Integer> chunkMatches = naiveSearchService.search(chunk, pattern); 
             
             // Aggregate and convert local indices to absolute indices
             Set<Integer> absoluteMatches = chunkMatches.stream()
                     .map(localIndex -> start + localIndex)
                     .collect(Collectors.toSet());
             
             return absoluteMatches;
         });
     }
     
     // 3. Parallel Execution and Aggregation (Master's role: Dispatch & Gather)
     long startTime = System.nanoTime();
     ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
     
     // invokeAll submits all tasks and blocks until all are complete (like imap_unordered in outcome)
     List<Future<Set<Integer>>> futures = executor.invokeAll(tasks);
     
     Set<Integer> allMatches = new HashSet<>();
     for (Future<Set<Integer>> future : futures) {
         allMatches.addAll(future.get()); // Aggregation and Collection
     }

     executor.shutdown(); // Gracefully shut down the pool
     long endTime = System.nanoTime();
     
     // 4. Construct Final Result
     MatchResult result = new MatchResult();
     result.setAlgorithm(request.getAlgorithm() + " Parallel (Dynamic)");
     result.setExecutionTimeNs(endTime - startTime);
     result.setMatchIndices(new ArrayList<>(allMatches));
     result.setTextLength(textLength);
     result.setPatternLength(patternLength);
     
     return result;
 }
}