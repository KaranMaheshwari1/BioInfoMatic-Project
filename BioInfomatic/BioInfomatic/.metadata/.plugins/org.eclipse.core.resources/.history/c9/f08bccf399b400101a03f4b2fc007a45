// src/main/java/com/example/bioinfo/service/ParallelGenericSearchService.java

package com.bio.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.bio.model.MatchRequest;
import com.bio.model.MatchResult;
import com.bio.utils.GenomeDataGenerator; // Import the updated utility

import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;
import java.io.IOException; // Important for file reading

@Service
public class ParallelGenericSearchService {

    private final NaiveSearchService naiveSearchService; 

    @Value("${app.parallel.num-threads:4}") 
    private int NUM_THREADS; 
    
    // Removed GENOME_LENGTH constant
    private static final int TASKS_PER_THREAD = 4;

    @Autowired
    public ParallelGenericSearchService(NaiveSearchService naiveSearchService) {
        this.naiveSearchService = naiveSearchService;
    }
    
    public MatchResult executeParallelSearch(MatchRequest request) throws Exception {
         
        // 1. Read the Massive Genomic Data from the file
        String pattern = request.getPattern();
        
        // --- FIX: Read from file instead of generating dynamically ---
        String text;
        try {
            text = GenomeDataGenerator.readGenomeFile();
        } catch (IOException e) {
            throw new Exception("Failed to read genome file. Ensure the file generation endpoint was successfully called.", e);
        }
        // -------------------------------------------------------------
        
        int textLength = text.length();
        int patternLength = pattern.length();
        
        // Use 4 threads (from property) * 4 tasks/thread for dynamic balancing
        final int NUM_TASKS = NUM_THREADS * TASKS_PER_THREAD; 

        // 2. Prepare Chunks with Overlap (Master's role: Data Decomposition)
        int chunkSizeBase = textLength / NUM_TASKS;
        int overlapSize = patternLength - 1; 
        
        List<Callable<Set<Integer>>> tasks = new ArrayList<>();
        
        for (int i = 0; i < NUM_TASKS; i++) {
            final int start = i * chunkSizeBase;
            int end = (i + 1) * chunkSizeBase;
            
            // Add overlap to all but the last chunk
            if (i < NUM_TASKS - 1) {
                end += overlapSize;
            }
            
            final String chunk = text.substring(start, Math.min(end, textLength));
            
            // Create the Callable task (Worker's role)
            tasks.add(() -> {
                // Use the injected sequential algorithm
                List<Integer> chunkMatches = naiveSearchService.search(chunk, pattern); 
                
                // Aggregate and convert local indices to absolute indices
                Set<Integer> absoluteMatches = chunkMatches.stream()
                        .map(localIndex -> start + localIndex)
                        .collect(Collectors.toSet());
                
                return absoluteMatches;
            });
        }
        
        // 3. Parallel Execution and Aggregation (Master's role: Dispatch & Gather)
        long startTime = System.nanoTime();
        ExecutorService executor = Executors.newFixedThreadPool(NUM_THREADS);
        
        List<Future<Set<Integer>>> futures = executor.invokeAll(tasks);
        
        Set<Integer> allMatches = new HashSet<>();
        for (Future<Set<Integer>> future : futures) {
            allMatches.addAll(future.get()); // Aggregation and Collection
        }

        executor.shutdown(); // Gracefully shut down the pool
        long endTime = System.nanoTime();
        
        // 4. Construct Final Result
        MatchResult result = new MatchResult();
        // Updated algorithm name to reflect file usage:
        result.setAlgorithm(request.getAlgorithm() + " Parallel (Dynamic - File)");
        result.setExecutionTimeNs(endTime - startTime);
        result.setMatchIndices(new ArrayList<>(allMatches));
        result.setTextLength(textLength);
        result.setPatternLength(patternLength);
        
        return result;
    }
}